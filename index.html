<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>æå¢ƒç½—é©¬ - ç»ˆæä¼˜åŒ–ç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #0f1215; font-family: "PingFang SC", "Microsoft YaHei", sans-serif; touch-action: none; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* UI è®¾è®¡ */
        #ui-layer {
            position: absolute; top: 20px; left: 20px; color: #e0e0e0; pointer-events: none; user-select: none; z-index: 5;
            border-left: 3px solid #d32f2f; padding-left: 15px; text-shadow: 0 2px 4px rgba(0,0,0,0.9);
        }
        h1 { margin: 0; font-size: 20px; font-weight: 700; letter-spacing: 4px; text-transform: uppercase; font-family: 'Songti SC', serif; }
        .sub-info { font-size: 12px; color: #b0bec5; letter-spacing: 1px; margin-top: 5px; font-family: "KaiTi", "æ¥·ä½“", serif; font-weight: 600; }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 6px; height: 6px; background: rgba(255, 50, 50, 0.8);
            border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; z-index: 10; display: none; 
        }

        #interact-tip {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); color: #ffeb3b;
            font-size: 16px; font-weight: bold; text-shadow: 0 2px 4px rgba(0,0,0,0.8); display: none;
            pointer-events: none; font-family: "KaiTi", "æ¥·ä½“", serif; letter-spacing: 2px; text-align: center; width: 100%;
        }

        .letterbox { position: absolute; left: 0; width: 100%; height: 6vh; background: #050505; z-index: 5; pointer-events: none; }
        .top-bar { top: 0; }
        .bottom-bar { bottom: 0; display: flex; justify-content: center; align-items: center; }

        #btn-container { position: absolute; bottom: 80px; width: 100%; display: flex; justify-content: center; pointer-events: auto; z-index: 10; }
        .btn {
            background: rgba(30, 40, 50, 0.8); color: #cfd8dc; border: 1px solid #546e7a; padding: 12px 30px;
            font-size: 14px; cursor: pointer; font-weight: 600; letter-spacing: 2px; transition: all 0.4s ease;
            box-shadow: 0 4px 10px rgba(0,0,0,0.6); font-family: "KaiTi", "æ¥·ä½“", serif;
        }
        .btn:hover { background: #455a64; color: #fff; border-color: #90a4ae; }

        #blocker {
            position: absolute; width: 100%; height: 100%; background-color: rgba(0,0,0,0.85);
            backdrop-filter: blur(10px); display: none; z-index: 999; justify-content: center;
            align-items: center; color: #eceff1; flex-direction: column; cursor: pointer;
        }
        #instructions {
            font-size: 20px; font-family: "KaiTi", "æ¥·ä½“", serif; letter-spacing: 4px;
            border-top: 1px solid #d32f2f; border-bottom: 1px solid #d32f2f; padding: 20px 40px; text-align: center;
        }
        
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #b0bec5; font-size: 12px; font-family: "KaiTi", "æ¥·ä½“", serif; letter-spacing: 2px;
            z-index: 20; transition: opacity 0.5s;
        }

        /* æ‰‹æœºæ§ä»¶ä¼˜åŒ– */
        #mobile-controls {
            position: absolute; bottom: 20px; width: 100%; height: 150px; display: none; z-index: 20; pointer-events: none;
        }
        .joystick-area {
            position: absolute; bottom: 20px; width: 120px; height: 120px;
            background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%; pointer-events: auto;
        }
        #stick-left { left: 30px; }
        #touch-right { right: 30px; border: none; background: rgba(0,0,0,0.05); }
        
        .stick-knob {
            position: absolute; top: 50%; left: 50%; width: 50px; height: 50px;
            background: rgba(255, 255, 255, 0.3); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none;
        }
        
        /* ä¼˜åŒ–åçš„äº¤äº’æŒ‰é’®ï¼šä½¿ç”¨æ‰‹æŒå›¾æ ‡ï¼Œé¢œè‰²æ›´æ¸©å’Œ */
        .interact-btn-mobile {
            position: absolute; bottom: 160px; right: 40px; width: 64px; height: 64px; border-radius: 50%;
            background: rgba(255, 255, 255, 0.2); border: 2px solid rgba(255, 255, 255, 0.3);
            color: white; font-size: 30px;
            display: none; justify-content: center; align-items: center; pointer-events: auto; z-index: 21;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            transition: background 0.3s, transform 0.1s;
        }
    </style>
</head>
<body>

    <div class="letterbox top-bar"></div>
    <div class="letterbox bottom-bar">
        <div id="btn-container">
            <button class="btn" id="toggle-view-btn">åˆ‡æ¢è§†è§’ / Enter</button>
        </div>
    </div>

    <div id="crosshair"></div>
    <div id="interact-tip">æŒ‰ [E] æˆ–ç‚¹å‡»æŒ‰é’®å¼€é—¨</div>

    <div id="loading">æ­£åœ¨ä¼˜åŒ–æ€§èƒ½å¹¶ç”Ÿæˆä¸–ç•Œ...</div>

    <div id="ui-layer">
        <h1>æš—é»‘ç½—é©¬</h1>
        <div class="sub-info">
            è­¦å‘Šï¼šå±‹å†…å‘ç°ç”Ÿå‘½ååº”<br>
            æ¢ç´¢ï¼šæ‰€æœ‰æˆ¿å±‹<br>
        </div>
    </div>

    <div id="blocker">
        <div id="instructions">ç‚¹å‡»å±å¹•ç»§ç»­</div>
    </div>

    <div id="mobile-controls">
        <div id="stick-left" class="joystick-area"><div class="stick-knob" id="knob-left"></div></div>
        <div id="touch-right" class="joystick-area" style="width: 40%; height: 60%; bottom: 20%; right: 0; border-radius: 0;"></div>
    </div>
    <!-- æ”¹ä¸ºæ‰‹æŒå›¾æ ‡ -->
    <div id="mobile-interact-btn" class="interact-btn-mobile">ğŸ–ï¸</div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/OrbitControls.js';
        import { PointerLockControls } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/PointerLockControls.js';
        import { Sky } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/objects/Sky.js';
        import { EffectComposer } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/postprocessing/UnrealBloomPass.js';
        import { FilmPass } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/postprocessing/FilmPass.js';

        // --- å˜é‡å®šä¹‰ ---
        let camera, scene, renderer, composer;
        let orbitControls, fpsControls;
        let sun, sky;
        const clouds = []; const birds = []; const monsters = []; let rainSystem;
        const raycaster = new THREE.Raycaster(); const center = new THREE.Vector2(0, 0); const doors = []; let hoveredDoor = null;
        let isFpsMode = false;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        const velocity = new THREE.Vector3(); const direction = new THREE.Vector3(); let prevTime = performance.now();
        
        // ç§»åŠ¨ç«¯æ£€æµ‹
        let isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
        let mobileMove = { x: 0, y: 0 };
        let cameraEuler = new THREE.Euler(0, 0, 0, 'YXZ');

        // --- æ€§èƒ½ä¼˜åŒ–å‚æ•° ---
        // æ‰‹æœºç«¯å¤§å¹…å‡å°‘æ¸²æŸ“å‹åŠ›
        const SETTINGS = {
            rainCount: isMobile ? 4000 : 30000, // æ‰‹æœºé›¨æ»´å‡å°‘åˆ° 4000
            houseCount: isMobile ? 20 : 50,     // æ‰‹æœºæˆ¿å­å‡å°‘åˆ° 20
            shadowSize: isMobile ? 512 : 2048,  // æ‰‹æœºé˜´å½±åˆ†è¾¨ç‡é™ä½
            pixelRatio: isMobile ? 1 : window.devicePixelRatio // æ‰‹æœºä¸ä½¿ç”¨è§†ç½‘è†œæ¸²æŸ“
        };

        // --- çº¹ç†å·¥å‚ ---
        const TextureFactory = {
            createNoiseCanvas: function(width, height, scale = 1.0, intensity = 255) {
                const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height;
                const ctx = canvas.getContext('2d'); const imgData = ctx.createImageData(width, height); const data = imgData.data;
                for (let i = 0; i < data.length; i += 4) { const val = (Math.random() * intensity) | 0; data[i] = val; data[i+1] = val; data[i+2] = val; data[i+3] = 255; }
                ctx.putImageData(imgData, 0, 0); return canvas;
            },
            createCobblestone: function() {
                const size = 512; // é™ä½çº¹ç†å°ºå¯¸ä¼˜åŒ–åŠ è½½
                const canvasColor = document.createElement('canvas'); const canvasNormal = document.createElement('canvas');
                canvasColor.width = canvasNormal.width = size; canvasColor.height = canvasNormal.height = size;
                const ctxC = canvasColor.getContext('2d'); const ctxN = canvasNormal.getContext('2d');
                ctxC.fillStyle = '#1a1510'; ctxC.fillRect(0, 0, size, size); ctxN.fillStyle = '#8080ff'; ctxN.fillRect(0, 0, size, size);
                const cols = 16, rows = 16, cellW = size / cols, cellH = size / rows;
                for(let y=0; y<rows; y++) {
                    for(let x=0; x<cols; x++) {
                        const offsetX = (Math.random() - 0.5) * (cellW * 0.4); const offsetY = (Math.random() - 0.5) * (cellH * 0.4);
                        const stoneW = cellW * (0.7 + Math.random() * 0.2); const stoneH = cellH * (0.7 + Math.random() * 0.2);
                        const cx = x * cellW + cellW/2 + offsetX; const cy = y * cellH + cellH/2 + offsetY;
                        const shade = 50 + Math.random() * 40; const color = `rgb(${shade}, ${shade*0.95}, ${shade*0.9})`;
                        ctxC.beginPath(); ctxC.ellipse(cx, cy, stoneW/2, stoneH/2, Math.random()*0.5, 0, Math.PI*2); ctxC.fillStyle = color; ctxC.fill();
                        const grad = ctxN.createRadialGradient(cx, cy, 0, cx, cy, Math.max(stoneW, stoneH)/2);
                        grad.addColorStop(0, '#ffffff'); grad.addColorStop(0.8, '#808080'); grad.addColorStop(1, '#000000'); 
                        ctxN.beginPath(); ctxN.ellipse(cx, cy, stoneW/2, stoneH/2, Math.random()*0.5, 0, Math.PI*2); ctxN.fillStyle = grad; ctxN.fill();
                    }
                }
                const noise = this.createNoiseCanvas(size, size, 1, 40); ctxC.globalCompositeOperation = 'multiply'; ctxC.drawImage(noise, 0, 0);
                const texDiffuse = new THREE.CanvasTexture(canvasColor); const texBump = new THREE.CanvasTexture(canvasNormal); 
                [texDiffuse, texBump].forEach(t => { t.wrapS = t.wrapT = THREE.RepeatWrapping; t.repeat.set(60, 60); t.anisotropy = isMobile ? 2 : 16; });
                return { diffuse: texDiffuse, bump: texBump };
            },
            createWood: function() {
                const size = 256; const canvas = document.createElement('canvas'); canvas.width = size; canvas.height = size;
                const ctx = canvas.getContext('2d'); ctx.fillStyle = '#2e1d10'; ctx.fillRect(0,0,size,size);
                ctx.strokeStyle = '#1a0f08'; ctx.lineWidth = 2; ctx.globalAlpha = 0.5;
                for(let i=0; i<50; i++) { const y = Math.random() * size; ctx.beginPath(); ctx.moveTo(0, y); ctx.bezierCurveTo(size/3, y + Math.random()*20, size*2/3, y - Math.random()*20, size, y); ctx.stroke(); }
                return new THREE.CanvasTexture(canvas);
            }
        };

        init();
        animate();

        function init() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x607080, 0.0025); 
            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.set(0, 40, 100);

            renderer = new THREE.WebGLRenderer({ antialias: !isMobile, powerPreference: "high-performance" }); // æ‰‹æœºå…³é—­æŠ—é”¯é½¿
            renderer.setSize(window.innerWidth, window.innerHeight); 
            renderer.setPixelRatio(SETTINGS.pixelRatio);
            renderer.physicallyCorrectLights = true; renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 0.8; 
            renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            initRainyEnvironment();
            const cobbleMats = TextureFactory.createCobblestone(); const woodTex = TextureFactory.createWood();
            document.getElementById('loading').style.opacity = 0;

            createRealisticGround(cobbleMats); createColosseum(); createMedievalCity(woodTex); 
            if (!isMobile) createDetails(); // æ‰‹æœºç«¯ä¸ç”Ÿæˆé¢å¤–çš„æœ¨æ¡¶ç»†èŠ‚ï¼ŒèŠ‚çœæ€§èƒ½
            createVolumetricClouds(); createBirds(); createRain();

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.7; bloomPass.strength = 0.4; bloomPass.radius = 0.5;
            
            // æ‰‹æœºç«¯ç§»é™¤ FilmPass å™ªç‚¹æ•ˆæœï¼Œæå‡æ€§èƒ½
            composer = new EffectComposer(renderer); composer.addPass(renderScene); composer.addPass(bloomPass);
            if (!isMobile) {
                const filmPass = new FilmPass(0.25, 0.05, 648, false);
                composer.addPass(filmPass);
            }

            orbitControls = new OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true; orbitControls.dampingFactor = 0.05; orbitControls.maxPolarAngle = Math.PI / 2 - 0.05; orbitControls.autoRotate = true; orbitControls.autoRotateSpeed = 0.1;

            fpsControls = new PointerLockControls(camera, document.body);
            setupFpsControls();
            setupMobileControls(); 

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown); document.addEventListener('keyup', onKeyUp);
            
            // ä¿®å¤ï¼šæŒ‰é’®ç‚¹å‡»åå¤±å»ç„¦ç‚¹ï¼Œé˜²æ­¢ç©ºæ ¼é”®è§¦å‘æŒ‰é’®
            const toggleBtn = document.getElementById('toggle-view-btn');
            toggleBtn.addEventListener('click', () => {
                toggleMode();
                toggleBtn.blur();
            });
        }

        function initRainyEnvironment() {
            sky = new Sky(); sky.scale.setScalar(450000); scene.add(sky);
            sun = new THREE.Vector3();
            const uniforms = sky.material.uniforms;
            uniforms['turbidity'].value = 20; uniforms['rayleigh'].value = 0.5; uniforms['mieCoefficient'].value = 0.05; uniforms['mieDirectionalG'].value = 0.1;
            const theta = Math.PI * (0.45 - 0.5); const phi = 2 * Math.PI * (0.25 - 0.5);
            sun.x = Math.cos(phi); sun.y = Math.sin(phi) * Math.sin(theta); sun.z = Math.sin(phi) * Math.cos(theta);
            uniforms['sunPosition'].value.copy(sun);
            const dirLight = new THREE.DirectionalLight(0x8899aa, 1.0); dirLight.position.set(50, 100, 50); dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = SETTINGS.shadowSize; dirLight.shadow.mapSize.height = SETTINGS.shadowSize; dirLight.shadow.bias = -0.0005;
            const d = 100; // å‡å°é˜´å½±èŒƒå›´
            dirLight.shadow.camera.left = -d; dirLight.shadow.camera.right = d; dirLight.shadow.camera.top = d; dirLight.shadow.camera.bottom = -d; scene.add(dirLight);
            const ambientLight = new THREE.AmbientLight(0x506070, 2.0); scene.add(ambientLight);
        }
        function createRealisticGround(mats) {
            const material = new THREE.MeshStandardMaterial({ map: mats.diffuse, bumpMap: mats.bump, bumpScale: 0.15, roughness: 0.2, metalness: 0.3, color: 0x888888 });
            const geometry = new THREE.PlaneGeometry(2000, 2000); const ground = new THREE.Mesh(geometry, material); ground.rotation.x = -Math.PI / 2; ground.receiveShadow = true; scene.add(ground);
        }
        function createRain() {
            const rainCount = SETTINGS.rainCount; const rainGeo = new THREE.BufferGeometry(); const rainPositions = [];
            for(let i=0; i<rainCount; i++) rainPositions.push((Math.random() - 0.5) * 400, Math.random() * 200, (Math.random() - 0.5) * 400);
            rainGeo.setAttribute('position', new THREE.Float32BufferAttribute(rainPositions, 3));
            const rainMat = new THREE.PointsMaterial({ color: 0xaaaaaa, size: 0.2, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending });
            rainSystem = new THREE.Points(rainGeo, rainMat); scene.add(rainSystem);
        }
        function createColosseum() {
            const group = new THREE.Group(); const stoneMat = new THREE.MeshStandardMaterial({ color: 0x8c8c8c, roughness: 0.4, metalness: 0.1 });
            const radiusX = 28, radiusZ = 22, heightPerTier = 6, tiers = 3;
            for(let t=0; t<tiers; t++) {
                const y = t * heightPerTier; const rx = radiusX - t; const rz = radiusZ - t;
                const shape = new THREE.Shape(); const curveOut = new THREE.EllipseCurve(0,0, rx, rz, 0, 2*Math.PI, false, 0); shape.setFromPoints(curveOut.getPoints(64)); // é™ä½ç‚¹æ•°
                const pathIn = new THREE.Path(); const curveIn = new THREE.EllipseCurve(0,0, rx-3, rz-3, 0, 2*Math.PI, true, 0); pathIn.setFromPoints(curveIn.getPoints(64)); shape.holes.push(pathIn);
                const geo = new THREE.ExtrudeGeometry(shape, { depth: 1.2, bevelEnabled: true, bevelThickness: 0.2, bevelSize: 0.1, bevelSegments: 1 }); // å‡å°‘å€’è§’æ®µæ•°
                geo.rotateX(Math.PI/2);
                const floor = new THREE.Mesh(geo, stoneMat); floor.position.y = y + heightPerTier; floor.castShadow = true; floor.receiveShadow = true; group.add(floor);
                const arches = 24; // å‡å°‘æ‹±é—¨æ•°é‡
                for(let i=0; i<arches; i++) { const angle = (i/arches) * Math.PI * 2; const px = Math.cos(angle) * (rx - 1.5); const pz = Math.sin(angle) * (rz - 1.5); const pillar = new THREE.Mesh(new THREE.BoxGeometry(1.8, heightPerTier, 1.8), stoneMat); pillar.position.set(px, y + heightPerTier/2, pz); pillar.lookAt(0, y + heightPerTier/2, 0); pillar.castShadow = true; pillar.receiveShadow = true; group.add(pillar); }
            }
            scene.add(group);
        }
        function createMonster(type) {
            const group = new THREE.Group();
            if (type === 0) { const geo = new THREE.SphereGeometry(0.6, 12, 12); const mat = new THREE.MeshPhysicalMaterial({ color: 0x00ff00, transmission: 0.8, opacity: 1, roughness: 0.1, metalness: 0, thickness: 1, clearcoat: 1.0, emissive: 0x003300 }); const mesh = new THREE.Mesh(geo, mat); mesh.position.y = 0.6; group.add(mesh); const eyeGeo = new THREE.SphereGeometry(0.1, 6, 6); const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 }); const leftEye = new THREE.Mesh(eyeGeo, eyeMat); leftEye.position.set(0.2, 0.8, 0.45); const rightEye = new THREE.Mesh(eyeGeo, eyeMat); rightEye.position.set(-0.2, 0.8, 0.45); group.add(leftEye); group.add(rightEye); group.userData = { type: 'slime', speed: 3 + Math.random() * 2, timeOff: Math.random() * 100 }; } 
            else if (type === 1) { const geo = new THREE.SphereGeometry(0.4, 12, 12); const mat = new THREE.MeshStandardMaterial({ color: 0xddeeff, transparent: true, opacity: 0.5, roughness: 0.5, emissive: 0x223344 }); const mesh = new THREE.Mesh(geo, mat); mesh.scale.y = 2.5; mesh.position.y = 1.5; group.add(mesh); const eyeGeo = new THREE.SphereGeometry(0.08, 6, 6); const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 }); const leftEye = new THREE.Mesh(eyeGeo, eyeMat); leftEye.position.set(0.15, 1.8, 0.35); const rightEye = new THREE.Mesh(eyeGeo, eyeMat); rightEye.position.set(-0.15, 1.8, 0.35); group.add(leftEye); group.add(rightEye); group.userData = { type: 'ghost', speed: 1 + Math.random(), timeOff: Math.random() * 100 }; } 
            else { const geo = new THREE.IcosahedronGeometry(0.5, 0); const mat = new THREE.MeshStandardMaterial({ color: 0x4b0082, emissive: 0x220044, roughness: 0.2, flatShading: true }); const mesh = new THREE.Mesh(geo, mat); mesh.position.y = 1.2; group.add(mesh); const partGeo = new THREE.BoxGeometry(0.1, 0.1, 0.1); const partMat = new THREE.MeshBasicMaterial({color: 0x9900ff}); for(let i=0; i<4; i++) { const part = new THREE.Mesh(partGeo, partMat); part.position.x = 0.8; const piv = new THREE.Group(); piv.position.y = 1.2; piv.rotation.y = i * (Math.PI/2); piv.add(part); piv.userData = { isOrbiter: true, speed: (i+1) * 2 }; group.add(piv); } group.userData = { type: 'orb', speed: 1, timeOff: Math.random() * 100 }; }
            return group;
        }
        function createMedievalCity(woodTex) {
            const plasterMat = new THREE.MeshStandardMaterial({ color: 0xaaa8a0, roughness: 0.7 }); const woodMat = new THREE.MeshStandardMaterial({ map: woodTex, color: 0x3d2817, roughness: 0.6 }); const roofMat = new THREE.MeshStandardMaterial({ color: 0x6d4c41, roughness: 0.5 }); const doorMat = new THREE.MeshStandardMaterial({ color: 0x2a1a0e, roughness: 0.8, bumpMap: woodTex, bumpScale: 0.1 });
            for(let i=0; i<SETTINGS.houseCount; i++) {
                const angle = Math.random() * Math.PI * 2; const dist = 50 + Math.random() * 150; const x = Math.cos(angle) * dist; const z = Math.sin(angle) * dist; const house = new THREE.Group(); house.position.set(x, 0, z); const rotY = Math.atan2(-x, -z) + (Math.random()-0.5); house.rotation.y = rotY;
                const w = 5 + Math.random() * 2; const d = 5 + Math.random() * 2; const groundH = 4; const upperH = 3.5; const wallThick = 0.2; const doorW = 1.4; const doorH = 2.4;
                const backWall = new THREE.Mesh(new THREE.BoxGeometry(w, groundH, wallThick), plasterMat); backWall.position.set(0, groundH/2, -d/2 + wallThick/2); backWall.castShadow = true; backWall.receiveShadow = true; house.add(backWall);
                const leftWall = new THREE.Mesh(new THREE.BoxGeometry(wallThick, groundH, d - wallThick*2), plasterMat); leftWall.position.set(-w/2 + wallThick/2, groundH/2, 0); leftWall.castShadow = true; leftWall.receiveShadow = true; house.add(leftWall);
                const rightWall = new THREE.Mesh(new THREE.BoxGeometry(wallThick, groundH, d - wallThick*2), plasterMat); rightWall.position.set(w/2 - wallThick/2, groundH/2, 0); rightWall.castShadow = true; rightWall.receiveShadow = true; house.add(rightWall);
                const frontSideW = (w - doorW) / 2;
                const fL = new THREE.Mesh(new THREE.BoxGeometry(frontSideW, groundH, wallThick), plasterMat); fL.position.set(-w/2 + frontSideW/2, groundH/2, d/2 - wallThick/2); fL.castShadow = true; fL.receiveShadow = true; house.add(fL);
                const fR = new THREE.Mesh(new THREE.BoxGeometry(frontSideW, groundH, wallThick), plasterMat); fR.position.set(w/2 - frontSideW/2, groundH/2, d/2 - wallThick/2); fR.castShadow = true; fR.receiveShadow = true; house.add(fR);
                const headerH = groundH - doorH; const fT = new THREE.Mesh(new THREE.BoxGeometry(doorW, headerH, wallThick), plasterMat); fT.position.set(0, groundH - headerH/2, d/2 - wallThick/2); fT.castShadow = true; fT.receiveShadow = true; house.add(fT);
                const doorPivot = new THREE.Group(); doorPivot.position.set(-doorW/2, 0, d/2 - wallThick/2); const doorMesh = new THREE.Mesh(new THREE.BoxGeometry(doorW, doorH, wallThick), doorMat); doorMesh.position.set(doorW/2, doorH/2, 0); doorMesh.castShadow = true; doorPivot.add(doorMesh); doorPivot.userData = { isDoor: true, isOpen: false, animation: 0 }; doors.push(doorPivot); house.add(doorPivot);
                const monsterType = Math.floor(Math.random() * 3); const monster = createMonster(monsterType); monster.position.set(0, 0, -d/4); monster.rotation.y = Math.PI; house.add(monster); monsters.push(monster);
                let lightColor = 0xffaa00; if (monsterType === 0) lightColor = 0x00ff00; else if (monsterType === 1) lightColor = 0xaaccff; else if (monsterType === 2) lightColor = 0xaa00ff;
                const innerLight = new THREE.PointLight(lightColor, 2.0, 8); innerLight.position.set(0, groundH/2, 0); house.add(innerLight);
                const overhang = 0.6; const upperW = w + overhang; const upperD = d + overhang; const upperGeo = new THREE.BoxGeometry(upperW, upperH, upperD); const upper = new THREE.Mesh(upperGeo, plasterMat); upper.position.y = groundH + upperH/2; upper.castShadow = true; upper.receiveShadow = true; house.add(upper);
                const beamThick = 0.3; const beams = [{x: -upperW/2, z: -upperD/2}, {x: upperW/2, z: -upperD/2}, {x: -upperW/2, z: upperD/2}, {x: upperW/2, z: upperD/2}]; beams.forEach(pos => { const beam = new THREE.Mesh(new THREE.BoxGeometry(beamThick, upperH, beamThick), woodMat); beam.position.set(pos.x, groundH + upperH/2, pos.z); house.add(beam); });
                const crossBeam = new THREE.Mesh(new THREE.BoxGeometry(upperW, beamThick, beamThick), woodMat); crossBeam.position.set(0, groundH + upperH/2, upperD/2); house.add(crossBeam);
                const roofH = 3 + Math.random() * 2; const roofGeo = new THREE.ConeGeometry(Math.max(upperW, upperD)*0.85, roofH, 4); const roof = new THREE.Mesh(roofGeo, roofMat); roof.position.y = groundH + upperH + roofH/2; roof.rotation.y = Math.PI/4; roof.scale.set(upperW/upperD > 1 ? 1.2 : 0.8, 1, upperD/upperW > 1 ? 1.2 : 0.8); roof.castShadow = true; house.add(roof);
                scene.add(house);
            }
        }
        function createDetails() {
            const barrelGeo = new THREE.CylinderGeometry(0.4, 0.4, 1, 12); const barrelMat = new THREE.MeshStandardMaterial({ color: 0x4a3c31, roughness: 0.6 }); const barrels = new THREE.InstancedMesh(barrelGeo, barrelMat, 300); const dummy = new THREE.Object3D();
            for(let i=0; i<300; i++) { const angle = Math.random() * Math.PI * 2; const dist = 40 + Math.random() * 120; dummy.position.set(Math.cos(angle)*dist, 0.5, Math.sin(angle)*dist); dummy.rotation.set(Math.random()*0.2, Math.random()*Math.PI, Math.random()*0.2); dummy.updateMatrix(); barrels.setMatrixAt(i, dummy.matrix); }
            barrels.castShadow = true; barrels.receiveShadow = true; scene.add(barrels);
        }
        function createVolumetricClouds() {
            const cloudGeo = new THREE.DodecahedronGeometry(1, 0); const cloudMat = new THREE.MeshStandardMaterial({ color: 0x8899aa, roughness: 0.9, transparent: true, opacity: 0.8, flatShading: true });
            for(let i=0; i<40; i++) { const cloud = new THREE.Group(); const puffs = 5 + Math.random()*6; for(let j=0; j<puffs; j++) { const puff = new THREE.Mesh(cloudGeo, cloudMat); puff.position.set(Math.random()*12-6, Math.random()*5-2.5, Math.random()*12-6); const s = 3 + Math.random()*4; puff.scale.set(s, s*0.7, s); cloud.add(puff); } cloud.position.set((Math.random()-0.5)*800, 100 + Math.random()*50, (Math.random()-0.5)*800); scene.add(cloud); clouds.push({ mesh: cloud, speed: 0.5 + Math.random()*0.8 }); }
        }
        function createBirds() {
            const geo = new THREE.BufferGeometry(); geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array([0.2,0,0, 0,0,-0.3, -0.2,0,0]), 3)); const mat = new THREE.MeshBasicMaterial({ color: 0x111111, side: THREE.DoubleSide });
            for(let i=0; i<60; i++) { const bird = new THREE.Mesh(geo, mat); bird.position.set(Math.random()*300-150, 50+Math.random()*40, Math.random()*300-150); scene.add(bird); birds.push({ mesh: bird, speed: 5+Math.random()*3, angle: Math.random()*Math.PI*2, yOff: Math.random()*100 }); }
        }

        function setupFpsControls() {
            const blocker = document.getElementById('blocker');
            const instructions = document.getElementById('instructions');
            const crosshair = document.getElementById('crosshair');
            
            blocker.addEventListener('click', () => {
                if (!isMobile) {
                    fpsControls.lock();
                } else {
                    if (!isFpsMode) toggleMode();
                    else blocker.style.display = 'none';
                }
            });

            fpsControls.addEventListener('lock', () => {
                instructions.style.display = 'none';
                blocker.style.display = 'none';
                if (isFpsMode && !isMobile) crosshair.style.display = 'block';
            });
            
            fpsControls.addEventListener('unlock', () => {
                if (isFpsMode && !isMobile) {
                    blocker.style.display = 'flex';
                    instructions.style.display = '';
                    crosshair.style.display = 'none';
                }
            });
        }

        function setupMobileControls() {
            if (!isMobile) return;
            document.getElementById('mobile-controls').style.display = 'block';
            document.getElementById('mobile-interact-btn').style.display = 'flex';
            const blocker = document.getElementById('blocker');
            const instructions = document.getElementById('instructions');
            instructions.innerHTML = "è½»è§¦å±å¹•å¼€å§‹";
            
            const stickLeft = document.getElementById('stick-left');
            const knobLeft = document.getElementById('knob-left');
            let touchIdLeft = null; const maxDist = 35;

            stickLeft.addEventListener('touchstart', (e) => { e.preventDefault(); const touch = e.changedTouches[0]; touchIdLeft = touch.identifier; updateStick(touch); }, {passive: false});
            stickLeft.addEventListener('touchmove', (e) => { e.preventDefault(); for (let i = 0; i < e.changedTouches.length; i++) { if (e.changedTouches[i].identifier === touchIdLeft) { updateStick(e.changedTouches[i]); break; } } }, {passive: false});
            const endStick = (e) => { e.preventDefault(); for (let i = 0; i < e.changedTouches.length; i++) { if (e.changedTouches[i].identifier === touchIdLeft) { touchIdLeft = null; knobLeft.style.transform = `translate(-50%, -50%)`; mobileMove.x = 0; mobileMove.y = 0; } } };
            stickLeft.addEventListener('touchend', endStick); stickLeft.addEventListener('touchcancel', endStick);

            function updateStick(touch) {
                const rect = stickLeft.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2; const centerY = rect.top + rect.height / 2;
                let dx = touch.clientX - centerX; let dy = touch.clientY - centerY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > maxDist) { dx = (dx / dist) * maxDist; dy = (dy / dist) * maxDist; }
                knobLeft.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                mobileMove.x = dx / maxDist; mobileMove.y = dy / maxDist;
            }

            const touchRight = document.getElementById('touch-right');
            let lastX = 0, lastY = 0;
            touchRight.addEventListener('touchstart', (e) => { e.preventDefault(); lastX = e.changedTouches[0].clientX; lastY = e.changedTouches[0].clientY; }, {passive: false});
            touchRight.addEventListener('touchmove', (e) => { e.preventDefault(); const touch = e.changedTouches[0]; const dx = touch.clientX - lastX; const dy = touch.clientY - lastY; lastX = touch.clientX; lastY = touch.clientY; if (isFpsMode) { const sensitivity = 0.005; cameraEuler.setFromQuaternion(camera.quaternion); cameraEuler.y -= dx * sensitivity; cameraEuler.x -= dy * sensitivity; cameraEuler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraEuler.x)); camera.quaternion.setFromEuler(cameraEuler); } }, {passive: false});

            const btn = document.getElementById('mobile-interact-btn');
            btn.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); interact(); btn.style.transform = "scale(0.9)"; btn.style.backgroundColor = "rgba(255,255,255,0.5)"; });
            btn.addEventListener('touchend', () => { btn.style.transform = "scale(1)"; btn.style.backgroundColor = "rgba(255,255,255,0.2)"; });
        }

        function interact() {
            if (hoveredDoor) hoveredDoor.userData.isOpen = !hoveredDoor.userData.isOpen;
        }

        function toggleMode() {
            isFpsMode = !isFpsMode;
            const blocker = document.getElementById('blocker');
            const crosshair = document.getElementById('crosshair');
            
            if (isFpsMode) {
                camera.position.set(0, 1.7, 90); 
                orbitControls.enabled = false;
                
                if (!isMobile) {
                    fpsControls.lock(); 
                    crosshair.style.display = 'block';
                } else {
                    blocker.style.display = 'none';
                    cameraEuler.setFromQuaternion(camera.quaternion);
                }
            } else {
                fpsControls.unlock();
                if (!isMobile) blocker.style.display = 'none';
                camera.position.set(0, 40, 100);
                orbitControls.enabled = true;
                crosshair.style.display = 'none';
            }
        }

        // ä¿®å¤ï¼šç©ºæ ¼é”®é€»è¾‘
        function onKeyDown(e) {
            switch (e.code) {
                case 'ArrowUp': case 'KeyW': moveForward = true; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                case 'ArrowRight': case 'KeyD': moveRight = true; break;
                case 'Space': 
                    e.preventDefault(); // é˜»æ­¢é»˜è®¤æ»šåŠ¨/ç‚¹å‡»è¡Œä¸º
                    if (isFpsMode && camera.position.y <= 1.8) velocity.y = 10; 
                    break;
                case 'KeyE': interact(); break;
            }
        }
        function onKeyUp(e) {
            switch (e.code) {
                case 'ArrowUp': case 'KeyW': moveForward = false; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                case 'ArrowRight': case 'KeyD': moveRight = false; break;
            }
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001; 
            const delta = 0.016; 
            
            monsters.forEach(m => {
                if (m.userData.type === 'slime') { m.position.y = 0.6 + Math.abs(Math.sin(time * m.userData.speed + m.userData.timeOff)) * 0.5; m.scale.y = 1 - Math.abs(Math.sin(time * m.userData.speed + m.userData.timeOff)) * 0.2; m.scale.x = m.scale.z = 1 + Math.abs(Math.sin(time * m.userData.speed + m.userData.timeOff)) * 0.1; } 
                else if (m.userData.type === 'ghost') { m.position.y = 1.5 + Math.sin(time * m.userData.speed + m.userData.timeOff) * 0.3; if (isFpsMode) m.lookAt(camera.position.x, m.position.y, camera.position.z); } 
                else if (m.userData.type === 'orb') { m.rotation.y += delta * m.userData.speed; m.children.forEach(child => { if (child.userData.isOrbiter) child.rotation.y += delta * child.userData.speed; }); }
            });

            if (isFpsMode) {
                raycaster.setFromCamera(center, camera);
                const intersects = raycaster.intersectObjects(scene.children, true);
                let foundDoor = null;
                for (let i = 0; i < intersects.length; i++) { if (intersects[i].distance > 6) break; let obj = intersects[i].object; while(obj) { if (obj.userData && obj.userData.isDoor) { foundDoor = obj; break; } obj = obj.parent; } if (foundDoor) break; }
                hoveredDoor = foundDoor;
                const tip = document.getElementById('interact-tip');
                if (hoveredDoor) {
                    tip.style.display = 'block'; tip.innerText = hoveredDoor.userData.isOpen ? "æŒ‰ [E] å…³é—¨" : "æŒ‰ [E] å¼€é—¨";
                    // æ‰‹æŒå›¾æ ‡å˜äº®
                    if (isMobile) document.getElementById('mobile-interact-btn').style.borderColor = "#00ff00";
                } else {
                    tip.style.display = 'none';
                    if (isMobile) document.getElementById('mobile-interact-btn').style.borderColor = "rgba(255,255,255,0.3)";
                }
            }

            doors.forEach(door => { const targetRot = door.userData.isOpen ? -Math.PI / 2 : 0; door.rotation.y += (targetRot - door.rotation.y) * delta * 5; });
            if (rainSystem) { const positions = rainSystem.geometry.attributes.position.array; for(let i=1; i<positions.length; i+=3) { positions[i] -= delta * 6000; if (positions[i] < 0) positions[i] = 200; } rainSystem.geometry.attributes.position.needsUpdate = true; }
            clouds.forEach(c => { c.mesh.position.x += c.speed * delta * 500; if(c.mesh.position.x > 500) c.mesh.position.x = -500; });
            birds.forEach(b => { b.mesh.position.x += Math.cos(b.angle)*b.speed*delta*60; b.mesh.position.z += Math.sin(b.angle)*b.speed*delta*60; b.mesh.position.y += Math.sin(time + b.yOff)*0.05; b.mesh.rotation.y = -b.angle; if(Math.abs(b.mesh.position.x)>400) b.mesh.position.x *= -0.9; if(Math.abs(b.mesh.position.z)>400) b.mesh.position.z *= -0.9; });

            if (isFpsMode) {
                velocity.x -= velocity.x * 10.0 * delta; velocity.z -= velocity.z * 10.0 * delta; velocity.y -= 9.8 * 3.0 * delta; 
                direction.z = Number(moveForward) - Number(moveBackward); direction.x = Number(moveRight) - Number(moveLeft);
                if (isMobile) { direction.x += mobileMove.x; direction.z += mobileMove.y; }
                direction.normalize();
                if (direction.lengthSq() > 0) { velocity.z -= direction.z * 150.0 * delta; velocity.x -= direction.x * 150.0 * delta; }
                fpsControls.moveRight(-velocity.x * delta); fpsControls.moveForward(-velocity.z * delta);
                camera.position.y += velocity.y * delta;
                if (camera.position.y < 1.7) { velocity.y = 0; camera.position.y = 1.7; }
            } else {
                orbitControls.update();
            }
            composer.render();
        }
    </script>
</body>
</html>